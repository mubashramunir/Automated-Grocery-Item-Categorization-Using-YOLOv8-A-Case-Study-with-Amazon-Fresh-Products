# -*- coding: utf-8 -*-
"""Automated Grocery Item Categorization Using YOLOv8: A Case Study with Amazon Fresh Products.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13DFPYQrRBCYWuLeGT27fllYk_OiPdT3i
"""

# Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

!pip install ultralytics
!pip install opencv-python-headless

import os
from google.colab import drive
import yaml
from ultralytics import YOLO


base_path = '/content/drive/MyDrive/dataset'
yaml_path = os.path.join(base_path, 'dataset.yaml')

# YAML file for dataset configuration
yaml_content = {
    "path": base_path,
    "train": "train/images",
    "val": "val/images",
    "test": "test/images",
    "nc": 46,
    "names": ['apples', 'avocados', 'banana', 'Beef', 'berries', 'Blush', 'Body Wash', 'Cereals',
              'Chicken', 'citrusfruits', 'Coffee', 'Conditioner', 'cucumber', 'driedfruits',
              'Eggs', 'Eyes', 'Face Wash', 'Feminine Care', 'Foundation', 'Fragrance',
              'Frozen Appetizers & Snacks', 'Frozen Meat', 'Frozen Pizza', 'Garlic', 'grapes',
              'Hand Soap', 'Jam', 'Juice', 'Lemon', 'lip care', 'Lip Color',
              'Makeup Brushes & Tools', 'melon', 'Milk', 'Moisturizer', 'MouthWash',
              'Nail Polish', 'pineapple', 'plum', 'Powder', 'Seafood', 'Shampoo',
              'Shave & HairRemoval', 'Soap', 'Toothpaste', 'Water']
}

# Write YAML file
with open(yaml_path, 'w') as file:
    yaml.dump(yaml_content, file, default_flow_style=False)

print(f"YAML file created at: {yaml_path}")

# Verify YAML file contents
with open(yaml_path, 'r') as file:
    print("\nYAML file contents:")
    print(file.read())

# Initialize YOLOv8 model
model = YOLO('yolov8n.pt')  # 'n' for nano, you can change to 's', 'm', 'l', or 'x' for other sizes

# Train the model
try:
    results = model.train(
        data=yaml_path,
        epochs=10,
        imgsz=640,
        batch=16,
        name='yolov8_custom_model'
    )

    # Save the trained model
    model.save(f'{base_path}/yolov8_custom_model.pt')
    print("Training completed and model saved!")

except Exception as e:
    print(f"An error occurred during training: {str(e)}")

    # Print directory structure for debugging
    print("\nDirectory structure:")
    for root, dirs, files in os.walk(base_path):
        level = root.replace(base_path, '').count(os.sep)
        indent = ' ' * 4 * (level)
        print(f"{indent}{os.path.basename(root)}/")
        subindent = ' ' * 4 * (level + 1)
        for f in files:
            print(f"{subindent}{f}")

results = model.train(data=yaml_path, epochs=20, imgsz=640, lr0=0.01)

results = model.train(
    data=yaml_path,
    epochs=50,
    imgsz=640,
    batch=16,
    lr0=0.01,
    optimizer='AdamW',
    weight_decay=0.0005,
    warmup_epochs=3,
    patience=50
)

from google.colab import files, drive
import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
from ultralytics import YOLO
import os

# Mount Google Drive
drive.mount('/content/drive')

# Upload an image
uploaded = files.upload()

# Get the filename of the uploaded image
filename = next(iter(uploaded))

# Read the image
image = cv2.imread(filename)
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  # Convert BGR to RGB

# Display the uploaded image
plt.figure(figsize=(10, 10))
plt.imshow(image)
plt.axis('off')
plt.title('Uploaded Image')
plt.show()

# Define the path to your best model
model_path = 'runs/detect/yolov8_custom_model22/weights/best.pt'

# Check if the model file exists
if not os.path.exists(model_path):
    print(f"Model file not found at {model_path}")
    print("Contents of the runs/detect/yolov8_custom_model22/weights folder:")
    print(os.listdir('runs/detect/yolov8_custom_model22/weights'))
else:
    # Load the PyTorch model
    try:
        model = YOLO(model_path)
        print(f"Model loaded successfully from {model_path}")

        # Perform inference
        results = model(image)

        # Display the results
        plt.figure(figsize=(10, 10))
        for r in results:
            im_array = r.plot()  # plot a BGR numpy array of predictions
            plt.imshow(cv2.cvtColor(im_array, cv2.COLOR_BGR2RGB))
        plt.axis('off')
        plt.title('Detected Objects')
        plt.show()

        # Function to print detailed results
        def print_results(results):
            for r in results:
                boxes = r.boxes
                for box in boxes:
                    c = box.cls
                    conf = box.conf
                    print(f"Detected class: {model.names[int(c)]}, Confidence: {conf.item():.2f}")

        # Print the results
        print_results(results)

    except Exception as e:
        print(f"Error loading or using the model: {e}")

!pip install ultralytics
!pip install opencv-python-headless

from ultralytics import YOLO
import os

# Define the base folder path
base_folder = '/content/drive/MyDrive/dataset'

# Define the path to your dataset.yaml file
yaml_path = os.path.join(base_folder, 'dataset.yaml')

# Define the path to your ONNX model
model_path = os.path.join(base_folder, 'yolov8_custom_model.pt')

# Load the model
model = YOLO(model_path)

# Run validation
try:
    results = model.val(data=yaml_path)
    print(results)
except Exception as e:
    print(f"An error occurred: {e}")
    print("Make sure the paths are correct and the YAML file is properly formatted.")

from ultralytics import YOLO
import os


# Define paths
base_folder = '/content/drive/MyDrive/dataset'
model_path = os.path.join(base_folder, 'yolov8_custom_model.pt')
yaml_path = os.path.join(base_folder, 'dataset.yaml')

# Load the model
model = YOLO(model_path)

# Print model information
print(model.info())

# Evaluate the model
try:
    results = model.val(data=yaml_path)
    print(results)
except Exception as e:
    print(f"An error occurred: {e}")
    print("Make sure the yaml_path is correct and the YAML file is properly formatted.")

# If you want to see more detailed results:
print("\nDetailed Results:")
for metric, value in results.results_dict.items():
    print(f"{metric}: {value}")

from PIL import Image

# Predict and plot
results = model('/content/drive/MyDrive/dataset/test/images')
im = Image.fromarray(results[0].plot())
im.show()

model.save('best_model.pt')

# Assuming 'results' is the output from model.val()
for i, c in enumerate(results.names):
    print(f"Class {c}: mAP = {results.maps[i]}")

model.export(format='onnx')

model.val(data=yaml_path, model='runs/detect/yolov8_custom_model22/weights/best.onnx')

from ultralytics import YOLO
import os
from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')

# Define paths
base_folder = '/content/drive/MyDrive/dataset'
model_path = os.path.join(base_folder, 'yolov8_custom_model.pt')  # Using .pt file
yaml_path = os.path.join(base_folder, 'dataset.yaml')

# Check if files exist
if not os.path.exists(model_path):
    raise FileNotFoundError(f"Model file not found: {model_path}")
if not os.path.exists(yaml_path):
    raise FileNotFoundError(f"YAML file not found: {yaml_path}")

# Load the model
try:
    model = YOLO(model_path)
    print("Model loaded successfully")
except Exception as e:
    print(f"Error loading model: {e}")
    raise

# Print model information
print(model.info())

# Evaluate the model
try:
    results = model.val(data=yaml_path)
    print("\nValidation Results:")
    print(results)
except Exception as e:
    print(f"An error occurred during validation: {e}")
    print("Make sure the yaml_path is correct and the YAML file is properly formatted.")

# If you want to see more detailed results:
if 'results' in locals():
    print("\nDetailed Results:")
    for metric, value in results.results_dict.items():
        print(f"{metric}: {value}")

# After running the model on your image
for r in results:
    for box in r.boxes:
        cls = int(box.cls[0])
        conf = float(box.conf[0])
        print(f"Detected class: {model.names[cls]}, Confidence: {conf:.2f}")

from ultralytics import YOLO
import os
from google.colab import drive

# Mount Google Drive
drive.mount('/content/drive')

# Define paths
base_folder = '/content/drive/MyDrive/dataset'
model_path = os.path.join(base_folder, 'yolov8_custom_model.pt')  # Using .pt file
yaml_path = os.path.join(base_folder, 'dataset.yaml')

# Check if files exist
if not os.path.exists(model_path):
    raise FileNotFoundError(f"Model file not found: {model_path}")
if not os.path.exists(yaml_path):
    raise FileNotFoundError(f"YAML file not found: {yaml_path}")

# Load the model
try:
    model = YOLO(model_path)
    print("Model loaded successfully")
except Exception as e:
    print(f"Error loading model: {e}")
    raise

# Print model information
print(model.info())

# Evaluate the model
try:
    results = model.val(data=yaml_path)
    print("\nValidation Results:")
    print(results)
except Exception as e:
    print(f"An error occurred during validation: {e}")
    print("Make sure the yaml_path is correct and the YAML file is properly formatted.")

# If you want to see more detailed results:
if 'results' in locals():
    print("\nDetailed Results:")
    for metric, value in results.results_dict.items():
        print(f"{metric}: {value}")

def print_results(results):
    for r in results:
        boxes = r.boxes
        for box in boxes:
            c = box.cls
            conf = box.conf
            print(f"Detected class: {model.names[int(c)]}, Confidence: {conf.item():.2f}")

print_results(results)

from ultralytics import YOLO
import os
from google.colab import drive
import cv2
import matplotlib.pyplot as plt
from IPython.display import display, clear_output
import ipywidgets as widgets

# Mount Google Drive if not already mounted
drive.mount('/content/drive')

# Path to your trained model
model_path = '/content/drive/MyDrive/dataset/yolov8_custom_model.pt'

# Load the model
model = YOLO(model_path)

# Print model information to verify it's loaded correctly
print(model.info())

class ModelReviewer:
    def __init__(self, base_folder, model, class_names):
        self.image_folder = os.path.join(base_folder, 'images')  # Changed from 'train/images' to 'images'
        self.images = [f for f in os.listdir(self.image_folder) if f.endswith(('.png', '.jpg', '.jpeg'))]
        self.current_index = 0
        self.model = model
        self.class_names = class_names
        self.fig, self.ax = plt.subplots(figsize=(12, 10))

        self.correct_button = widgets.Button(description="Correct")
        self.incorrect_button = widgets.Button(description="Incorrect")
        self.correct_button.on_click(self.mark_correct)
        self.incorrect_button.on_click(self.mark_incorrect)

        self.output = widgets.Output()
        display(widgets.HBox([self.correct_button, self.incorrect_button]), self.output)

        self.show_image()

    def show_image(self):
        with self.output:
            clear_output(wait=True)
            if self.current_index < len(self.images):
                img_path = os.path.join(self.image_folder, self.images[self.current_index])

                # Read image
                img = cv2.imread(img_path)
                img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

                # Run inference
                results = self.model(img)[0]

                self.ax.clear()
                self.ax.imshow(img)

                # Plot predictions
                for box in results.boxes:
                    x1, y1, x2, y2 = box.xyxy[0]
                    class_id = int(box.cls)
                    conf = float(box.conf)
                    class_name = self.class_names[class_id]

                    self.ax.add_patch(plt.Rectangle((x1, y1), x2-x1, y2-y1, fill=False, edgecolor='red', linewidth=2))
                    self.ax.text(x1, y1, f'{class_name} {conf:.2f}', color='red', fontsize=12, verticalalignment='top')

                self.ax.set_title(f"Image: {self.images[self.current_index]}")
                plt.show()
            else:
                print("All images reviewed!")

    def mark_correct(self, b):
        with self.output:
            print(f"Image {self.images[self.current_index]} marked as correct")
        self.next_image()

    def mark_incorrect(self, b):
        with self.output:
            print(f"Image {self.images[self.current_index]} marked as incorrect")
        self.next_image()

    def next_image(self):
        self.current_index += 1
        self.show_image()

# List of class names (make sure this matches your dataset's classes)
class_names = ['apples', 'avocados', 'banana', 'Beef', 'berries', 'Blush', 'Body Wash', 'Cereals',
               'Chicken', 'citrusfruits', 'Coffee', 'Conditioner', 'cucumber', 'driedfruits',
               'Eggs', 'Eyes', 'Face Wash', 'Feminine Care', 'Foundation', 'Fragrance',
               'Frozen Appetizers & Snacks', 'Frozen Meat', 'Frozen Pizza', 'Garlic', 'grapes',
               'Hand Soap', 'Jam', 'Juice', 'Lemon', 'lip care', 'Lip Color',
               'Makeup Brushes & Tools', 'melon', 'Milk', 'Moisturizer', 'MouthWash',
               'Nail Polish', 'pineapple', 'plum', 'Powder', 'Seafood', 'Shampoo',
                'Shave & HairRemoval', 'Soap', 'Toothpaste', 'Water']

# Usage
reviewer = ModelReviewer('/content/drive/MyDrive/dataset', model, class_names)

import os

base_dir = '/content/drive/MyDrive/dataset'
print("Contents of dataset directory:")
print(os.listdir(base_dir))

train_dir = os.path.join(base_dir, 'train')
if os.path.exists(train_dir):
    print("\nContents of train directory:")
    print(os.listdir(train_dir))
else:
    print("\ntrain directory not found")

!pip install playwright
!playwright install
!pip install nest_asyncio

import asyncio
import nest_asyncio
from playwright.async_api import async_playwright
import os
import shutil

nest_asyncio.apply()  # Apply the patch to allow nested event loops

async def scrape_images(url):
    # Clear the images directory before downloading new images
    folder_path = 'images'
    if os.path.exists(folder_path):
        shutil.rmtree(folder_path)  # Remove the entire images folder
        print(f"Cleared the images folder: {folder_path}")
    os.makedirs(folder_path, exist_ok=True)

    async with async_playwright() as p:
        # Launch the browser
        browser = await p.chromium.launch(headless=True)

        # Create a new browser context with custom headers to disable caching
        context = await browser.new_context(
            extra_http_headers={
                "Cache-Control": "no-store"
            }
        )

        # Open a new page in the context
        page = await context.new_page()

        # Navigate to the URL
        await page.goto(url, wait_until='networkidle')  # Wait for initial load

        # Scroll to the bottom to load more images
        for _ in range(3):  # Adjust the number of scrolls based on the page length
            await page.evaluate('window.scrollTo(0, document.body.scrollHeight)')
            await page.wait_for_timeout(2000)  # Wait for images to load

        # Get image URLs
        img_urls = await page.evaluate('''Array.from(document.querySelectorAll('img')).map(img => img.src)''')
        img_urls = list(filter(lambda x: x.startswith('http'), img_urls))  # Filter out non-http URLs
        print(f"Found {len(img_urls)} images.")

        for img_url in img_urls:
            img_name = os.path.join(folder_path, img_url.split('/')[-1])
            try:
                img_response = await page.request.get(img_url)
                img_data = await img_response.body()
                with open(img_name, 'wb') as f:
                    f.write(img_data)
                print(f'Downloaded {img_name}')
            except Exception as e:
                print(f'Failed to download {img_url}. Error: {e}')

        await browser.close()

# Change the URL and scrape
url = 'https://www.amazon.com/alm/category/?almBrandId=QW1hem9uIEZyZXNo&node=3777891&ref_=md_dsk_cp_ai_sml_4_3760911&pd_rd_w=ooTNu&content-id=amzn1.sym.441dd161-b383-478f-b238-9c21abc99a81&pf_rd_p=441dd161-b383-478f-b238-9c21abc99a81&pf_rd_r=WY7W4JAGVKR36TBY7PWG&pd_rd_wg=aTZsS&pd_rd_r=97f0ee7d-8a94-44ff-b2b8-9bd6182c29be'
# Run the async function
asyncio.run(scrape_images(url))